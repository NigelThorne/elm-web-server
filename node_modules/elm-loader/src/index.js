var fs = require("fs");
var path = require("path");
var vm = require("vm");

var execSync = require("child_process").execSync;
var EventEmitter = require("events").EventEmitter;

var jsdom = require("jsdom").jsdom;
var Inflect = require("inflect-js");

/*
 * constructor function
 */
function ElmRunner(filename, baseDir, defaults) {
  var relativePath = path.relative(baseDir, filename);
  var baseName = path.basename(filename, path.extname(filename));

  this.filename = filename;
  this.defaults = defaults || {};

  this.moduleName = resolveModuleName(relativePath);
  this.outputPath = path.join(path.dirname(filename), baseName + ".js");

  var self = this;
  withCheckedPath(this.outputPath, function() {
    try {
      compile.call(self);
      execute.call(self);
      wrap.call(self);
    } catch (e) {
      return e;
    }

    return true;
  });
}

/**
 * expose a factory function that wraps new instances
 */
module.exports = function(filename, baseDir, defaults) {
  return new ElmRunner(filename, baseDir, defaults);
};

function withCheckedPath(outputPath, callback) {
  if (fs.existsSync(outputPath)) {
    throw "Elm: File with name (" + outputPath + ") would be overwritten";
  } else {
    var result = callback();

    try {
      fs.unlinkSync(outputPath);
    } catch(e) { };


    if (result !== true) {
      process.stderr.write("Elm: An error ocurred during processing\n");
      process.stderr.write(result.toString() + "\n");
    }
  }
}

/**
 * run elm module through `elm-make` to generate compiled js
 */
function compile() {
  execSync("elm-make --yes " + this.filename + " --output " + this.outputPath);
}

/**
 * execute script generated by elm-make in a vm context
 */
function execute() {
  var context = getDefaultContext();
  var compiledOutput = fs.readFileSync(this.outputPath)

  vm.runInContext(compiledOutput, context, this.outputPath);

  var module = extractModule(this.moduleName, context);

  this.compiledModule = context.Elm.fullscreen(module, this.defaults);
}

/**
 * wrap compiled and executed object in EventEmitters
 */
function wrap() {
  var ports = this.compiledModule.ports;

  var incomingEmitter = new EventEmitter();
  var outgoingEmitter = new EventEmitter();

  var emit = incomingEmitter.emit.bind(incomingEmitter);

  Object.keys(ports).forEach(function(key) {
    outgoingEmitter.addListener(key, function() {
      var args = Array.prototype.slice.call(arguments)

      ports[key].send.apply(ports[key], args);
    });

    if (ports[key].subscribe) {
      ports[key].subscribe(function() {
        var args = Array.prototype.slice.call(arguments);
        args.unshift(key);

        emit.apply(incomingEmitter, args);
      });
    }
  });

  incomingEmitter.emit = outgoingEmitter.emit.bind(outgoingEmitter);;

  this.emitter = incomingEmitter;
  this.ports = this.compiledModule.ports;
}

function getDefaultContext() {
  var document = jsdom();

  return vm.createContext({
    document: document,
    window: document.parentWindow,

    setInterval: setInterval,
    clearInterval: clearInterval,

    setTimeout: setTimeout,
    clearTimeout: clearTimeout
  });
}

function resolveModuleName(relativePath) {
  var extIndex = relativePath.length - path.extname(relativePath).length;
  var pathWithoutExt = relativePath.substr(0, extIndex);

  if (relativePath.indexOf(path.sep) > -1) {
    var pathParts = pathWithoutExt.split(path.sep);
  } else {
    var pathParts = [pathWithoutExt];
  }

  return pathParts.map(function(part) {
    if (part.match(/^[A-Z]/)) {
      return part;
    } else {
      return Inflect.classify(part);
    }
  }).join(".");
}

function extractModule(moduleName, context) {
  if (moduleName.match(/\./)) {
    return module = moduleName.split(".").reduce(function(memo, property) {
      return memo[property];
    }, context.Elm);
  } else {
    return module = context.Elm[moduleName]
  }
}
